#include <LiquidCrystal.h>
#include <Keypad.h>

// ====== PIN DEFINITIONS (MATCHING YOUR WIRING) ======
#define LCD_RS 12
#define LCD_E  11
#define LCD_D4 5
#define LCD_D5 4
#define LCD_D6 3
#define LCD_D7 2

#define GREEN_LED 13  // External green LED (also lights onboard LED)
#define RED_LED   10  // Red LED
#define BUZZER_PIN 18 // A4 = digital pin 18

// LCD initialization (4-bit mode)
LiquidCrystal lcd(LCD_RS, LCD_E, LCD_D4, LCD_D5, LCD_D6, LCD_D7);

// Keypad configuration
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {9, 8, 7, 6};      // R1→9, R2→8, R3→7, R4→6
byte colPins[COLS] = {14, 15, 16, 17};  // A0=14, A1=15, A2=16, A3=17
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

// Extended victory melody (1.8 seconds total)
void playVictoryMelody() {
  // Sequence: Rising triplets with rhythmic pauses
  tone(BUZZER_PIN, 1000, 150); delay(160);
  tone(BUZZER_PIN, 1300, 150); delay(160);
  tone(BUZZER_PIN, 1600, 150); delay(200);
  
  tone(BUZZER_PIN, 1000, 150); delay(160);
  tone(BUZZER_PIN, 1300, 150); delay(160);
  tone(BUZZER_PIN, 1600, 150); delay(200);
  
  tone(BUZZER_PIN, 1200, 200); delay(210);
  tone(BUZZER_PIN, 1800, 250); delay(260);
  noTone(BUZZER_PIN);
}

// Extended error sound (1.2 seconds total)
void playErrorSound() {
  // Sad descending tones with vibration effect
  tone(BUZZER_PIN, 400, 200); delay(210);
  tone(BUZZER_PIN, 300, 200); delay(210);
  tone(BUZZER_PIN, 200, 300); delay(310);
  
  // Vibration effect (rapid low pulses)
  for (int i = 0; i < 4; i++) {
    tone(BUZZER_PIN, 150, 60);
    delay(70);
  }
  noTone(BUZZER_PIN);
}

// ====== GLOBAL VARIABLES ======
enum State {
  STATE_WELCOME,
  STATE_SELECT_TABLE,
  STATE_SELECT_MIN,
  STATE_SELECT_MAX,
  STATE_ASKING,
  STATE_CORRECT,
  STATE_INCORRECT
};

State currentState = STATE_WELCOME;
int tableNumber = 0;
int minMultiplier = 0;
int maxMultiplier = 20;
int currentA = 0, currentB = 0;
int answer = 0;
unsigned long lastActionTime = 0;
const unsigned long TIMEOUT_MS = 2500;  // WAS 1500 - now 2.5 seconds for extended feedback

String inputBuffer = "";                // User input buffer
String resetSequence = "";              // Tracks reset code progress (e.g., "ABCD")
int invalidAttempts = 0;
const int MAX_INVALID_ATTEMPTS = 5;
const String VALID_RESET_CODE = "ABCD"; // Note: # is the TRIGGER, not part of sequence

// ====== SETUP ======
void setup() {
  pinMode(GREEN_LED, OUTPUT);
  pinMode(RED_LED, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(GREEN_LED, LOW);
  digitalWrite(RED_LED, LOW);
  noTone(BUZZER_PIN);
  
  lcd.begin(16, 2);
  lcd.clear();
  
  randomSeed(analogRead(A5) + millis());
  
  showWelcome();
}

// ====== MAIN LOOP ======
void loop() {
  char key = keypad.getKey();
  
  // CRITICAL FIX: Intercept ALL keys during gameplay to handle reset sequence completion with #
  if (key && currentState == STATE_ASKING) {
    if (handleResetAttempt(key)) {
      return; // Reset sequence handled (either progress, completion, or error)
    }
    // If not part of reset sequence, fall through to normal answer handling
  }

  switch (currentState) {
    case STATE_WELCOME:
      if (key == '#') {
        currentState = STATE_SELECT_TABLE;
        showTableSelection();
      }
      break;
      
    case STATE_SELECT_TABLE:
      handleTableSelection(key);
      break;
      
    case STATE_SELECT_MIN:
      handleMinSelection(key);
      break;
      
    case STATE_SELECT_MAX:
      handleMaxSelection(key);
      break;
      
    case STATE_ASKING:
      handleAnswerInput(key);
      break;
      
    case STATE_CORRECT:
    case STATE_INCORRECT:
      if (millis() - lastActionTime > TIMEOUT_MS) {
        currentState = STATE_ASKING;
        generateNewQuestion();
        displayQuestion();
      }
      break;
  }
}

// ====== RESET SEQUENCE HANDLER (FULLY ROBUST) ======
// Returns true if key was consumed by reset logic (no further processing needed)
bool handleResetAttempt(char key) {
  // CASE 1: Sequence already complete ("ABCD" entered) - waiting for # to trigger reset
  if (resetSequence == VALID_RESET_CODE) {
    if (key == '#') {
      // FULL RESET TRIGGERED - start reconfiguration
      resetSequence = "";
      invalidAttempts = 0;
      triggerFullReset();
      return true; // Consumed
    } else {
      // Wrong key after ABCD - invalidate sequence
      resetSequence = "";
      invalidAttempts++;
      handleInvalidAttempt();
      return true; // Consumed (error shown)
    }
  }
  
  // CASE 2: Building sequence - only accept valid next character
  if (key == 'A' || key == 'B' || key == 'C' || key == 'D') {
    // Check if this is the expected next character
    if (resetSequence.length() < VALID_RESET_CODE.length()) {
      char expected = VALID_RESET_CODE.charAt(resetSequence.length());
      
      if (key == expected) {
        resetSequence += key;
        showResetProgress();
        return true; // Consumed
      } else {
        // Wrong character in sequence
        resetSequence = "";
        invalidAttempts++;
        handleInvalidAttempt();
        return true; // Consumed (error shown)
      }
    }
  }
  
  // CASE 3: Any other key (digits, *, etc.) breaks an incomplete sequence
  if (resetSequence.length() > 0) {
    resetSequence = "";
    invalidAttempts++;
    handleInvalidAttempt();
    return true; // Consumed (error shown)
  }
  
  // CASE 4: No active sequence - key not consumed (allow normal answer input)
  return false;
}

void showResetProgress() {
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("Enter Code:");
  
  // Show progress with actual characters entered so far
  lcd.setCursor(0, 1);
  lcd.print(resetSequence);
  
  // Show next expected character
  if (resetSequence.length() < VALID_RESET_CODE.length()) {
    lcd.print(" ");
    lcd.print(VALID_RESET_CODE.charAt(resetSequence.length()));
    lcd.print(" ...");
  } else {
    lcd.print(" # (confirm)");
  }
}

void triggerFullReset() {
  // Trigger complete reconfiguration flow
  currentState = STATE_SELECT_TABLE;
  showTableSelection();
  
  // Visual confirmation
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("Select Table");
  lcd.setCursor(0, 1);
  lcd.print("0-99 then #");
  delay(3000);
}

void handleInvalidAttempt() {
  if (invalidAttempts >= MAX_INVALID_ATTEMPTS) {
    showResetHint();
    invalidAttempts = 0;
  } else {
    showError("Invalid code!");
  }
}

// ====== CONFIGURATION FLOW HANDLERS ======
void showWelcome() {
  lcd.clear();
  delay(2);
  lcd.setCursor(1, 0);
  lcd.print("MULTIPLIER");
  lcd.setCursor(3, 1);
  lcd.print("TRAINER");
  delay(3500);
  
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("Press # to start");
  lcd.setCursor(0, 1);
  lcd.print("Fun Math Game!");
}

void showTableSelection() {
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("Select Table:");
  lcd.setCursor(0, 1);
  lcd.print("0-99 then #");
  inputBuffer = "";
  resetSequence = ""; // Clear any partial reset sequence
}

void handleTableSelection(char key) {
  if (!key) return;
  
  if (key >= '0' && key <= '9') {
    if (inputBuffer.length() < 2) {
      inputBuffer += key;
      lcd.setCursor(0, 1);
      lcd.print("                ");
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer);
    }
  } 
  else if (key == '*') { // Backspace
    if (inputBuffer.length() > 0) {
      inputBuffer.remove(inputBuffer.length() - 1);
      lcd.setCursor(0, 1);
      lcd.print("                ");
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer.length() > 0 ? inputBuffer : "_");
    }
  }
  else if (key == '#') { // Submit table
    if (inputBuffer.length() > 0) {
      tableNumber = inputBuffer.toInt();
      if (tableNumber >= 0 && tableNumber <= 99) {
        currentState = STATE_SELECT_MIN;
        showMinSelection();
      } else {
        showError("0-99 only!");
        inputBuffer = "";
      }
    } else {
      showError("Enter number!");
    }
  }
  // During configuration, ignore reset code attempts
}

void showMinSelection() {
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("MIN Multiplier:");
  lcd.setCursor(0, 1);
  lcd.print("0-99 then #");
  inputBuffer = "";
}

void handleMinSelection(char key) {
  if (!key) return;
  
  if (key >= '0' && key <= '9') {
    if (inputBuffer.length() < 2) {
      inputBuffer += key;
      lcd.setCursor(0, 1);
      lcd.print("                ");
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer);
    }
  } 
  else if (key == '*') {
    if (inputBuffer.length() > 0) {
      inputBuffer.remove(inputBuffer.length() - 1);
      lcd.setCursor(0, 1);
      lcd.print("                ");
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer.length() > 0 ? inputBuffer : "_");
    }
  }
  else if (key == '#') {
    if (inputBuffer.length() > 0) {
      minMultiplier = inputBuffer.toInt();
      if (minMultiplier >= 0 && minMultiplier <= 99) {
        currentState = STATE_SELECT_MAX;
        showMaxSelection();
      } else {
        showError("0-99 only!");
        inputBuffer = "";
      }
    } else {
      showError("Enter value!");
    }
  }
}

void showMaxSelection() {
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("MAX Multiplier:");
  lcd.setCursor(0, 1);
  lcd.print("0-99 then #");
  inputBuffer = "";
}

void handleMaxSelection(char key) {
  if (!key) return;
  
  if (key >= '0' && key <= '9') {
    if (inputBuffer.length() < 2) {
      inputBuffer += key;
      lcd.setCursor(0, 1);
      lcd.print("                ");
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer);
    }
  } 
  else if (key == '*') {
    if (inputBuffer.length() > 0) {
      inputBuffer.remove(inputBuffer.length() - 1);
      lcd.setCursor(0, 1);
      lcd.print("                ");
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer.length() > 0 ? inputBuffer : "_");
    }
  }
  else if (key == '#') {
    if (inputBuffer.length() > 0) {
      maxMultiplier = inputBuffer.toInt();
      if (maxMultiplier >= 0 && maxMultiplier <= 99) {
        if (maxMultiplier < minMultiplier) {
          showError("MAX < MIN!");
          delay(500);
          showMaxSelection();
        } else {
          // ALL CONFIGURATION COMPLETE - START GAMEPLAY
          inputBuffer = "";
          generateNewQuestion();
          currentState = STATE_ASKING;
          displayQuestion();
        }
      } else {
        showError("0-99 only!");
        inputBuffer = "";
      }
    } else {
      showError("Enter value!");
    }
  }
}

// ====== GAMEPLAY HANDLERS ======
void generateNewQuestion() {
  currentA = random(minMultiplier, maxMultiplier + 1);
  currentB = tableNumber;
  answer = currentA * currentB;
  inputBuffer = "";
  digitalWrite(GREEN_LED, LOW);
  digitalWrite(RED_LED, LOW);
}

void displayQuestion() {
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print(currentA);
  lcd.print(" x ");
  lcd.print(currentB);
  lcd.print(" = ?");
  
  lcd.setCursor(0, 1);
  lcd.print("Ans: ");
  if (inputBuffer.length() == 0) {
    lcd.print("_");
  } else {
    lcd.print(inputBuffer);
  }
}

void handleAnswerInput(char key) {
  if (!key) return;
  
  if (key >= '0' && key <= '9') {
    if (inputBuffer.length() < 4) {
      inputBuffer += key;
      lcd.setCursor(5, 1);
      lcd.print("    ");
      lcd.setCursor(5, 1);
      lcd.print(inputBuffer);
    }
  } 
  else if (key == '*') { // Backspace
    if (inputBuffer.length() > 0) {
      inputBuffer.remove(inputBuffer.length() - 1);
      lcd.setCursor(5, 1);
      lcd.print("    ");
      lcd.setCursor(5, 1);
      lcd.print(inputBuffer.length() > 0 ? inputBuffer : "_");
    }
  }
  else if (key == '#') { // Submit answer
    if (inputBuffer.length() > 0) {
      int userAnswer = inputBuffer.toInt();
      if (userAnswer == answer) {
        handleCorrectAnswer();
      } else {
        handleIncorrectAnswer();
      }
    } else {
      showError("Enter answer!");
    }
  }
  // Note: Reset sequence handling happens BEFORE this function via handleResetAttempt()
}

void handleCorrectAnswer() {
  currentState = STATE_CORRECT;
  lastActionTime = millis();  // Start 2.5-second feedback timer
  
  digitalWrite(GREEN_LED, HIGH);
  digitalWrite(RED_LED, LOW);
  
  // Play extended victory melody (non-blocking friendly)
  playVictoryMelody();
  
  // Show celebratory message immediately
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("CORRECT! :)");
  lcd.setCursor(0, 1);
  lcd.print("Excellent Work!");
  // LEDs stay ON until state changes (handled in main loop)
}

void handleIncorrectAnswer() {
  currentState = STATE_INCORRECT;
  lastActionTime = millis();  // Start 2.5-second feedback timer
  
  digitalWrite(RED_LED, HIGH);
  digitalWrite(GREEN_LED, LOW);
  
  // Play extended error sound
  playErrorSound();
  
  // Show helpful feedback immediately
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("Try Again!");
  lcd.setCursor(0, 1);
  lcd.print("Correct is: ");
  lcd.print(answer);
  // LEDs stay ON until state changes (handled in main loop)
}

// ====== UTILITY FUNCTIONS ======
void showError(String message) {
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("ERROR");
  lcd.setCursor(0, 1);
  lcd.print(message);
  delay(3000);
}

void showResetHint() {
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("RESET CODE:");
  lcd.setCursor(0, 1);
  lcd.print("A B C D #");
  delay(2500);
  
  // Return to gameplay state
  if (tableNumber > 0 && minMultiplier <= maxMultiplier) {
    currentState = STATE_ASKING;
    lcd.clear();
    displayQuestion();
  } else {
    currentState = STATE_SELECT_TABLE;
    showTableSelection();
  }
}
