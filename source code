#include <LiquidCrystal.h>
#include <Keypad.h>

// ====== PIN DEFINITIONS (MATCHING YOUR WIRING) ======
#define LCD_RS 12
#define LCD_E  11
#define LCD_D4 5
#define LCD_D5 4
#define LCD_D6 3
#define LCD_D7 2

#define GREEN_LED 13  // External green LED (also lights onboard LED)
#define RED_LED   10  // Red LED
#define BUZZER_PIN 18 // A4 = digital pin 18

// LCD initialization (4-bit mode)
LiquidCrystal lcd(LCD_RS, LCD_E, LCD_D4, LCD_D5, LCD_D6, LCD_D7);

// Keypad configuration
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {9, 8, 7, 6};      // R1→9, R2→8, R3→7, R4→6
byte colPins[COLS] = {14, 15, 16, 17};  // A0=14, A1=15, A2=16, A3=17
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

// ====== GLOBAL VARIABLES ======
enum State {
  STATE_WELCOME,
  STATE_SELECT_TABLE,
  STATE_ASKING,
  STATE_CORRECT,
  STATE_INCORRECT,
  STATE_ENTER_MIN,
  STATE_ENTER_MAX
};

State currentState = STATE_WELCOME;
int tableNumber = 0;
int minMultiplier = 0;
int maxMultiplier = 20;
int currentA = 0, currentB = 0;
int answer = 0;
unsigned long lastActionTime = 0;
const unsigned long TIMEOUT_MS = 1500;

String inputBuffer = "";                // User input buffer (answers, table selection, range values)
String resetSequence = "";              // Tracks reset code progress
int invalidAttempts = 0;
const int MAX_INVALID_ATTEMPTS = 5;
const String VALID_RESET_CODE = "ABCD#";

// ====== SETUP ======
void setup() {
  pinMode(GREEN_LED, OUTPUT);
  pinMode(RED_LED, OUTPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(GREEN_LED, LOW);
  digitalWrite(RED_LED, LOW);
  noTone(BUZZER_PIN);
  
  lcd.begin(16, 2);
  lcd.clear();
  
  randomSeed(analogRead(A5) + millis());
  
  showWelcome();
}

// ====== MAIN LOOP ======
void loop() {
  char key = keypad.getKey();
  
  // ONLY intercept LETTERS for reset sequence (CRITICAL FIX: # is NEVER intercepted here)
  if (key && (currentState == STATE_ASKING || currentState == STATE_SELECT_TABLE)) {
    if (key == 'A' || key == 'B' || key == 'C' || key == 'D') {
      if (handleResetSequence(key)) {
        return; // Reset sequence handled completely
      }
    }
  }

  switch (currentState) {
    case STATE_WELCOME:
      if (key == '#') {
        currentState = STATE_SELECT_TABLE;
        showTableSelection();
      }
      break;
      
    case STATE_SELECT_TABLE:
      handleTableSelection(key);
      break;
      
    case STATE_ASKING:
      handleAnswerInput(key);
      break;
      
    case STATE_CORRECT:
    case STATE_INCORRECT:
      if (millis() - lastActionTime > TIMEOUT_MS) {
        currentState = STATE_ASKING; // CRITICAL: Set state BEFORE generating question
        generateNewQuestion();
        displayQuestion();
      }
      break;
      
    case STATE_ENTER_MIN:
      handleRangeInput(key, true);
      break;
      
    case STATE_ENTER_MAX:
      handleRangeInput(key, false);
      break;
  }
}

// ====== RESET SEQUENCE HANDLER (STRICT SEQUENTIAL VALIDATION) ======
bool handleResetSequence(char key) {
  // Only 'A' can start a new sequence
  if (resetSequence.length() == 0) {
    if (key == 'A') {
      resetSequence = "A";
      showCodeProgress();
      return true; // Handled
    } else {
      // Invalid start character
      invalidAttempts++;
      handleInvalidAttempt();
      return true;
    }
  }
  
  // Validate next character in sequence
  String expectedNext = VALID_RESET_CODE.substring(resetSequence.length(), resetSequence.length() + 1);
  
  if (String(key) == expectedNext) {
    resetSequence += key;
    
    // Full sequence matched?
    if (resetSequence == VALID_RESET_CODE) {
      resetSequence = "";
      invalidAttempts = 0;
      enterNewRange();
      return true;
    } else {
      showCodeProgress();
      return true;
    }
  } else {
    // Sequence broken
    invalidAttempts++;
    resetSequence = "";
    handleInvalidAttempt();
    return true;
  }
}

void handleInvalidAttempt() {
  if (invalidAttempts >= MAX_INVALID_ATTEMPTS) {
    showResetHint();
    invalidAttempts = 0;
  } else {
    showError("Invalid code!");
  }
}

void showCodeProgress() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Code:");
  
  // Show asterisks for entered characters
  for (int i = 0; i < resetSequence.length(); i++) {
    lcd.print("*");
  }
  // Show next expected character hint
  if (resetSequence.length() < VALID_RESET_CODE.length() - 1) {
    lcd.print(" ");
    lcd.print(VALID_RESET_CODE.charAt(resetSequence.length()));
  }
}

// ====== STATE HANDLERS ======
void showWelcome() {
  lcd.clear();
  lcd.setCursor(1, 0);
  lcd.print("MULTIPLIER");
  lcd.setCursor(3, 1);
  lcd.print("TRAINER");
  delay(2000);
  
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Press # to start");
  lcd.setCursor(0, 1);
  lcd.print("Fun Math Game!");
}

void showTableSelection() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Select Table:");
  lcd.setCursor(0, 1);
  lcd.print("0-99 then #");
}

void handleTableSelection(char key) {
  if (!key) return;
  
  if (key >= '0' && key <= '9') {
    if (inputBuffer.length() < 2) {
      inputBuffer += key;
      // CRITICAL FIX: Clear entire second line before printing
      lcd.setCursor(0, 1);
      lcd.print("                "); // Clear 16 spaces
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer);
    }
  } 
  else if (key == '*') { // Backspace
    if (inputBuffer.length() > 0) {
      inputBuffer.remove(inputBuffer.length() - 1);
      lcd.setCursor(0, 1);
      lcd.print("                "); // Clear entire line
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer.length() > 0 ? inputBuffer : "_");
    }
  }
  else if (key == '#') { // Submit table
    if (inputBuffer.length() > 0) {
      tableNumber = inputBuffer.toInt();
      if (tableNumber >= 0 && tableNumber <= 99) {
        inputBuffer = "";
        generateNewQuestion();
        currentState = STATE_ASKING;
        displayQuestion();
      } else {
        showError("0-99 only!");
        inputBuffer = "";
      }
    } else {
      showError("Enter number!");
    }
  }
}

void generateNewQuestion() {
  currentA = random(minMultiplier, maxMultiplier + 1);
  currentB = tableNumber;
  answer = currentA * currentB;
  inputBuffer = "";
  digitalWrite(GREEN_LED, LOW);
  digitalWrite(RED_LED, LOW);
}

void displayQuestion() {
  // CRITICAL FIX: Add delay after clear for LCD stabilization
  lcd.clear();
  delay(2); // Allow LCD to process clear command
  
  lcd.setCursor(0, 0);
  lcd.print(currentA);
  lcd.print(" x ");
  lcd.print(currentB);
  lcd.print(" = ?");
  
  lcd.setCursor(0, 1);
  lcd.print("Ans: ");
  if (inputBuffer.length() == 0) {
    lcd.print("_");
  } else {
    lcd.print(inputBuffer);
  }
}

void handleAnswerInput(char key) {
  if (!key) return;
  
  if (key >= '0' && key <= '9') {
    if (inputBuffer.length() < 4) {
      inputBuffer += key;
      // CRITICAL FIX: Clear answer area properly
      lcd.setCursor(5, 1);
      lcd.print("    "); // Clear 4 spaces for answer
      lcd.setCursor(5, 1);
      lcd.print(inputBuffer);
    }
  } 
  else if (key == '*') { // Backspace
    if (inputBuffer.length() > 0) {
      inputBuffer.remove(inputBuffer.length() - 1);
      lcd.setCursor(5, 1);
      lcd.print("    "); // Clear area
      lcd.setCursor(5, 1);
      lcd.print(inputBuffer.length() > 0 ? inputBuffer : "_");
    }
  }
  else if (key == '#') { // Submit answer
    if (inputBuffer.length() > 0) {
      int userAnswer = inputBuffer.toInt();
      if (userAnswer == answer) {
        handleCorrectAnswer();
      } else {
        handleIncorrectAnswer(userAnswer);
      }
    } else {
      showError("Enter answer!");
    }
  }
}

void handleCorrectAnswer() {
  currentState = STATE_CORRECT;
  lastActionTime = millis();
  
  digitalWrite(GREEN_LED, HIGH);
  digitalWrite(RED_LED, LOW);
  
  // Victory melody
  tone(BUZZER_PIN, 1000, 120); delay(130);
  tone(BUZZER_PIN, 1500, 120); delay(130);
  tone(BUZZER_PIN, 2000, 120); delay(130);
  noTone(BUZZER_PIN);
  
  // CRITICAL FIX: Clear screen BEFORE printing new content
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("CORRECT! :)");
  lcd.setCursor(0, 1);
  lcd.print("Score: ");
  lcd.print(random(100, 999));
}

void handleIncorrectAnswer(int userAnswer) {
  currentState = STATE_INCORRECT;
  lastActionTime = millis();
  
  digitalWrite(RED_LED, HIGH);
  digitalWrite(GREEN_LED, LOW);
  
  // Error sound
  tone(BUZZER_PIN, 300, 300); delay(320);
  noTone(BUZZER_PIN);
  
  // CRITICAL FIX: Clear screen properly
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("Wrong! ");
  lcd.print(userAnswer);
  lcd.setCursor(0, 1);
  lcd.print("Correct: ");
  lcd.print(answer);
}

void enterNewRange() {
  inputBuffer = "";
  currentState = STATE_ENTER_MIN;
  
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("New MIN (0-99):");
  lcd.setCursor(0, 1);
  lcd.print("_");
}

void handleRangeInput(char key, bool isMin) {
  if (!key) return;
  
  if (key >= '0' && key <= '9') {
    if (inputBuffer.length() < 2) {
      inputBuffer += key;
      // CRITICAL FIX: Clear entire second line before printing new value
      lcd.setCursor(0, 1);
      lcd.print("                "); // Clear 16 spaces
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer);
    }
  } 
  else if (key == '*') { // Backspace
    if (inputBuffer.length() > 0) {
      inputBuffer.remove(inputBuffer.length() - 1);
      lcd.setCursor(0, 1);
      lcd.print("                "); // Clear line
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer.length() > 0 ? inputBuffer : "_");
    }
  }
  else if (key == '#') { // Submit value
    if (inputBuffer.length() > 0) {
      int value = inputBuffer.toInt();
      if (value >= 0 && value <= 99) {
        if (isMin) {
          minMultiplier = value;
          inputBuffer = "";
          currentState = STATE_ENTER_MAX;
          lcd.clear();
          delay(2);
          lcd.setCursor(0, 0);
          lcd.print("New MAX (0-99):");
          lcd.setCursor(0, 1);
          lcd.print("_");
        } else {
          if (value < minMultiplier) {
            showError("MAX < MIN!");
            delay(1200);
            enterNewRange();
          } else {
            maxMultiplier = value;
            inputBuffer = "";
            generateNewQuestion();
            currentState = STATE_ASKING;
            displayQuestion();
          }
        }
      } else {
        showError("0-99 only!");
        inputBuffer = "";
      }
    } else {
      showError("Enter value!");
    }
  }
}

// ====== UTILITY FUNCTIONS ======
void showError(String message) {
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("ERROR");
  lcd.setCursor(0, 1);
  lcd.print(message);
  delay(1500);
  
  // Restore appropriate UI with proper clearing
  switch (currentState) {
    case STATE_SELECT_TABLE:
      showTableSelection();
      if (inputBuffer.length() > 0) {
        lcd.setCursor(0, 1);
        lcd.print("                ");
        lcd.setCursor(0, 1);
        lcd.print(inputBuffer);
      }
      break;
    case STATE_ASKING:
      displayQuestion();
      break;
    case STATE_ENTER_MIN:
      lcd.clear();
      delay(2);
      lcd.setCursor(0, 0);
      lcd.print("New MIN (0-99):");
      lcd.setCursor(0, 1);
      lcd.print("                ");
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer.length() > 0 ? inputBuffer : "_");
      break;
    case STATE_ENTER_MAX:
      lcd.clear();
      delay(2);
      lcd.setCursor(0, 0);
      lcd.print("New MAX (0-99):");
      lcd.setCursor(0, 1);
      lcd.print("                ");
      lcd.setCursor(0, 1);
      lcd.print(inputBuffer.length() > 0 ? inputBuffer : "_");
      break;
    default:
      break;
  }
}

void showResetHint() {
  lcd.clear();
  delay(2);
  lcd.setCursor(0, 0);
  lcd.print("RESET CODE:");
  lcd.setCursor(0, 1);
  lcd.print("A B C D #");
  delay(2500);
  
  if (tableNumber > 0) {
    currentState = STATE_ASKING;
    displayQuestion();
  } else {
    currentState = STATE_SELECT_TABLE;
    showTableSelection();
  }
}
